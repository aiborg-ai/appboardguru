name: Infrastructure Management

on:
  push:
    branches: [ main ]
    paths:
      - 'infrastructure/**'
      - 'k8s/**'
      - '.github/workflows/infrastructure.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'infrastructure/**'
      - 'k8s/**'
  workflow_dispatch:
    inputs:
      action:
        description: 'Infrastructure action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
        - plan
        - apply
        - destroy
        - validate
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      auto_approve:
        description: 'Auto-approve Terraform changes (use with caution)'
        required: false
        default: false
        type: boolean

env:
  TF_VERSION: '1.7.0'
  TERRAFORM_CLOUD_TOKENS: ${{ secrets.TF_API_TOKEN }}
  AWS_REGION: 'us-east-1'

jobs:
  # Terraform validation and planning
  terraform-plan:
    runs-on: ubuntu-latest
    environment: 
      name: ${{ inputs.environment || 'staging' }}
    outputs:
      tfplan-exitcode: ${{ steps.plan.outputs.exitcode }}
      tfplan-stdout: ${{ steps.plan.outputs.stdout }}
      tfplan-stderr: ${{ steps.plan.outputs.stderr }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Format Check
        working-directory: ./infrastructure
        run: terraform fmt -check -recursive

      - name: Terraform Initialize
        working-directory: ./infrastructure
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=boardguru/${{ inputs.environment || 'staging' }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Validate
        working-directory: ./infrastructure
        run: terraform validate

      - name: Terraform Security Scan with tfsec
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: ./infrastructure
          format: sarif
          sarif_file: tfsec-results.sarif

      - name: Upload tfsec results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: tfsec-results.sarif

      - name: Terraform Plan
        id: plan
        working-directory: ./infrastructure
        run: |
          set -e
          terraform plan \
            -var="environment=${{ inputs.environment || 'staging' }}" \
            -var="region=${{ env.AWS_REGION }}" \
            -out=tfplan \
            -no-color \
            -detailed-exitcode
        continue-on-error: true

      - name: Save Terraform plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ inputs.environment || 'staging' }}
          path: infrastructure/tfplan
          retention-days: 30

      - name: Comment PR with plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const plan = `${{ steps.plan.outputs.stdout }}`;
            const comment = `
            ## Terraform Plan Results
            
            **Environment:** ${{ inputs.environment || 'staging' }}
            **Action:** Plan
            **Exit Code:** ${{ steps.plan.outputs.exitcode }}
            
            \`\`\`terraform
            ${plan}
            \`\`\`
            
            **Plan Status:** ${plan.includes('No changes') ? '✅ No changes' : '⚠️ Changes detected'}
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Terraform apply (only for main branch or manual dispatch)
  terraform-apply:
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && inputs.action == 'apply')
    environment:
      name: ${{ inputs.environment || 'staging' }}
      url: ${{ steps.outputs.outputs.app_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download Terraform plan
        uses: actions/download-artifact@v4
        with:
          name: tfplan-${{ inputs.environment || 'staging' }}
          path: infrastructure/

      - name: Terraform Initialize
        working-directory: ./infrastructure
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=boardguru/${{ inputs.environment || 'staging' }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Apply
        working-directory: ./infrastructure
        run: |
          if [ "${{ inputs.auto_approve }}" = "true" ]; then
            terraform apply -auto-approve tfplan
          else
            terraform apply tfplan
          fi

      - name: Get Terraform Outputs
        id: outputs
        working-directory: ./infrastructure
        run: |
          echo "app_url=$(terraform output -raw app_url)" >> $GITHUB_OUTPUT
          echo "rds_endpoint=$(terraform output -raw rds_endpoint)" >> $GITHUB_OUTPUT
          echo "eks_cluster_name=$(terraform output -raw eks_cluster_name)" >> $GITHUB_OUTPUT

      - name: Update infrastructure inventory
        run: |
          cat > infrastructure-inventory.json << EOF
          {
            "environment": "${{ inputs.environment || 'staging' }}",
            "region": "${{ env.AWS_REGION }}",
            "app_url": "${{ steps.outputs.outputs.app_url }}",
            "rds_endpoint": "${{ steps.outputs.outputs.rds_endpoint }}",
            "eks_cluster": "${{ steps.outputs.outputs.eks_cluster_name }}",
            "last_updated": "$(date -Iseconds)",
            "deployed_by": "${{ github.actor }}"
          }
          EOF

      - name: Upload infrastructure inventory
        uses: actions/upload-artifact@v4
        with:
          name: infrastructure-inventory-${{ inputs.environment || 'staging' }}
          path: infrastructure-inventory.json
          retention-days: 90

  # Kubernetes deployment
  k8s-deploy:
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: needs.terraform-apply.result == 'success'
    environment:
      name: ${{ inputs.environment || 'staging' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ inputs.environment || 'staging' }}-cluster

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.14.0'

      - name: Validate Kubernetes manifests
        run: |
          # Validate YAML syntax
          for file in k8s/*.yaml; do
            kubectl --dry-run=client -o yaml apply -f "$file"
          done

      - name: Deploy base infrastructure
        run: |
          # Apply base infrastructure
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/configmaps/
          kubectl apply -f k8s/secrets/
          
          # Wait for namespace to be ready
          kubectl wait --for=condition=Active --timeout=60s namespace/boardguru-${{ inputs.environment || 'staging' }}

      - name: Deploy monitoring stack
        run: |
          # Install Prometheus and Grafana
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo update
          
          helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
            --namespace monitoring \
            --create-namespace \
            --values k8s/monitoring/prometheus-values.yaml
          
          helm upgrade --install grafana grafana/grafana \
            --namespace monitoring \
            --values k8s/monitoring/grafana-values.yaml

      - name: Deploy application
        run: |
          # Deploy main application
          kubectl apply -f k8s/app/
          
          # Wait for deployment to be ready
          kubectl wait --for=condition=Available --timeout=600s \
            deployment/boardguru-app -n boardguru-${{ inputs.environment || 'staging' }}

      - name: Deploy ingress and load balancer
        run: |
          # Install NGINX Ingress Controller
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx \
            --create-namespace \
            --values k8s/ingress/nginx-values.yaml
          
          # Apply ingress rules
          kubectl apply -f k8s/ingress/

      - name: Verify deployment
        run: |
          echo "Verifying deployment health..."
          
          # Check pod status
          kubectl get pods -n boardguru-${{ inputs.environment || 'staging' }}
          
          # Check service endpoints
          kubectl get svc -n boardguru-${{ inputs.environment || 'staging' }}
          
          # Run health check
          kubectl run health-check-${{ github.run_number }} \
            --image=curlimages/curl \
            --rm -i --restart=Never \
            --namespace=boardguru-${{ inputs.environment || 'staging' }} \
            -- curl -f http://boardguru-app-service:3000/api/health

      - name: Update deployment status
        run: |
          kubectl annotate deployment boardguru-app \
            deployment.kubernetes.io/revision="${{ github.run_number }}" \
            deployment.kubernetes.io/git-commit="${{ github.sha }}" \
            deployment.kubernetes.io/deployed-by="${{ github.actor }}" \
            deployment.kubernetes.io/deployed-at="$(date -Iseconds)" \
            -n boardguru-${{ inputs.environment || 'staging' }}

  # Infrastructure destroy (manual only)
  terraform-destroy:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && inputs.action == 'destroy'
    environment:
      name: ${{ inputs.environment }}-destroy
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Initialize
        working-directory: ./infrastructure
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=boardguru/${{ inputs.environment }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Destroy Plan
        working-directory: ./infrastructure
        run: |
          terraform plan -destroy \
            -var="environment=${{ inputs.environment }}" \
            -var="region=${{ env.AWS_REGION }}" \
            -out=destroy-plan

      - name: Terraform Destroy (with confirmation)
        working-directory: ./infrastructure
        run: |
          echo "⚠️  WARNING: This will destroy all infrastructure for ${{ inputs.environment }}"
          terraform apply destroy-plan

      - name: Notify destruction
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "attachments": [{
                "color": "warning",
                "title": "🗑️ Infrastructure Destroyed",
                "text": "Infrastructure for ${{ inputs.environment }} has been destroyed",
                "fields": [{
                  "title": "Environment",
                  "value": "${{ inputs.environment }}",
                  "short": true
                }, {
                  "title": "Destroyed by",
                  "value": "${{ github.actor }}",
                  "short": true
                }]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.INFRASTRUCTURE_SLACK_WEBHOOK }}

  # Monitoring and alerting setup
  setup-monitoring:
    runs-on: ubuntu-latest
    needs: k8s-deploy
    if: needs.k8s-deploy.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ inputs.environment || 'staging' }}-cluster

      - name: Setup CloudWatch Container Insights
        run: |
          # Install CloudWatch Agent
          kubectl apply -f https://raw.githubusercontent.com/aws-samples/amazon-cloudwatch-container-insights/latest/k8s-deployment-manifest-templates/deployment-mode/daemonset/container-insights-monitoring/cloudwatch-namespace.yaml
          kubectl apply -f https://raw.githubusercontent.com/aws-samples/amazon-cloudwatch-container-insights/latest/k8s-deployment-manifest-templates/deployment-mode/daemonset/container-insights-monitoring/cwagent/cwagent-daemonset.yaml

      - name: Configure Prometheus alerts
        run: |
          kubectl apply -f k8s/monitoring/alerts/

      - name: Setup log aggregation
        run: |
          # Install Fluent Bit for log forwarding
          helm repo add fluent https://fluent.github.io/helm-charts
          helm repo update
          
          helm upgrade --install fluent-bit fluent/fluent-bit \
            --namespace logging \
            --create-namespace \
            --values k8s/logging/fluent-bit-values.yaml

      - name: Configure synthetic monitoring
        run: |
          # Create synthetic monitoring checks
          kubectl apply -f k8s/monitoring/synthetic-checks/

  # Cost optimization analysis
  cost-analysis:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || inputs.action == 'validate'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Run Infracost analysis
        uses: infracost/actions/setup@v2
        with:
          api-key: ${{ secrets.INFRACOST_API_KEY }}

      - name: Generate cost estimate
        run: |
          cd infrastructure
          infracost breakdown --path . \
            --format json \
            --out-file infracost.json
          
          infracost output --path infracost.json \
            --format table \
            --out-file cost-analysis.txt

      - name: Upload cost analysis
        uses: actions/upload-artifact@v4
        with:
          name: cost-analysis-${{ inputs.environment || 'staging' }}
          path: |
            infrastructure/infracost.json
            infrastructure/cost-analysis.txt
          retention-days: 90

      - name: Comment PR with cost analysis
        if: github.event_name == 'pull_request'
        uses: infracost/actions/comment@v1
        with:
          path: infrastructure/infracost.json
          behavior: update

  # Infrastructure drift detection
  drift-detection:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check for infrastructure drift
        working-directory: ./infrastructure
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=boardguru/production/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"
          
          terraform plan -detailed-exitcode -no-color > drift-check.txt
          DRIFT_EXIT_CODE=$?
          
          if [ $DRIFT_EXIT_CODE -eq 2 ]; then
            echo "Infrastructure drift detected!"
            echo "DRIFT_DETECTED=true" >> $GITHUB_ENV
          else
            echo "No infrastructure drift detected"
            echo "DRIFT_DETECTED=false" >> $GITHUB_ENV
          fi

      - name: Create drift alert
        if: env.DRIFT_DETECTED == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const driftDetails = fs.readFileSync('infrastructure/drift-check.txt', 'utf8');
            
            const title = `🚨 Infrastructure Drift Detected`;
            const body = `
            ## Infrastructure Drift Alert
            
            Terraform has detected that the actual infrastructure differs from the desired state defined in code.
            
            **Environment:** Production
            **Detection Date:** ${new Date().toISOString()}
            **Workflow Run:** ${{ github.run_number }}
            
            ### Drift Details:
            \`\`\`
            ${driftDetails}
            \`\`\`
            
            **Actions Required:**
            - [ ] Review the drift details above
            - [ ] Determine if changes were made outside of Terraform
            - [ ] Either import the changes into Terraform or revert the manual changes
            - [ ] Apply Terraform to restore desired state
            
            **Documentation:** [Infrastructure Drift Response](https://docs.boardguru.ai/infrastructure/drift-response)
            `;
            
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['infrastructure', 'drift', 'urgent']
            });