#!/usr/bin/env node

/**
 * Feature Generation CLI Tool
 * Generates complete domain modules with all necessary files
 */

const fs = require('fs').promises
const path = require('path')
const { program } = require('commander')

program
  .name('generate-feature')
  .description('Generate a new domain feature with all boilerplate code')
  .version('1.0.0')

program
  .command('domain <name>')
  .description('Generate a complete domain module')
  .option('-e, --entity <entity>', 'Entity name (defaults to domain name)')
  .option('-t, --table <table>', 'Database table name (defaults to plural entity)')
  .option('-f, --force', 'Overwrite existing files')
  .action(async (domainName, options) => {
    try {
      await generateDomain(domainName, options)
      console.log(`✅ Successfully generated domain: ${domainName}`)
    } catch (error) {
      console.error(`❌ Error generating domain: ${error.message}`)
      process.exit(1)
    }
  })

program
  .command('api <route>')
  .description('Generate API route handlers')
  .option('-d, --domain <domain>', 'Domain name', 'shared')
  .option('-m, --methods <methods>', 'HTTP methods (GET,POST,PUT,DELETE)', 'GET,POST,PUT,DELETE')
  .action(async (route, options) => {
    try {
      await generateAPIRoute(route, options)
      console.log(`✅ Successfully generated API route: ${route}`)
    } catch (error) {
      console.error(`❌ Error generating API route: ${error.message}`)
      process.exit(1)
    }
  })

program
  .command('component <name>')
  .description('Generate React component with hooks')
  .option('-d, --domain <domain>', 'Domain name', 'shared')
  .option('-t, --type <type>', 'Component type (list|detail|form|card)', 'detail')
  .action(async (componentName, options) => {
    try {
      await generateComponent(componentName, options)
      console.log(`✅ Successfully generated component: ${componentName}`)
    } catch (error) {
      console.error(`❌ Error generating component: ${error.message}`)
      process.exit(1)
    }
  })

program
  .command('test <domain>')
  .description('Generate comprehensive test suite for domain')
  .option('-t, --type <type>', 'Test type (api|service|repository|component|all)', 'all')
  .action(async (domainName, options) => {
    try {
      await generateTests(domainName, options)
      console.log(`✅ Successfully generated tests for domain: ${domainName}`)
    } catch (error) {
      console.error(`❌ Error generating tests: ${error.message}`)
      process.exit(1)
    }
  })

program.parse()

/**
 * Generate complete domain module
 */
async function generateDomain(domainName, options) {
  const entityName = options.entity || toPascalCase(domainName)
  const tableName = options.table || toPlural(toSnakeCase(entityName))
  
  const domainPath = path.join(process.cwd(), 'src', 'domains', domainName.toLowerCase())
  
  // Check if domain already exists
  if (!options.force && await pathExists(domainPath)) {
    throw new Error(`Domain ${domainName} already exists. Use --force to overwrite.`)
  }

  // Create directory structure
  await createDirectoryStructure(domainPath)
  
  // Generate all files
  await Promise.all([
    generateDomainTypes(domainPath, entityName, domainName),
    generateRepository(domainPath, entityName, tableName),
    generateService(domainPath, entityName, domainName),
    generateAPIHandlers(domainPath, entityName, domainName),
    generateHooks(domainPath, entityName, domainName),
    generateComponents(domainPath, entityName, domainName),
    generateDomainIndex(domainPath, entityName, domainName),
    generateDomainTests(domainPath, entityName, domainName, tableName)
  ])
}

/**
 * Create directory structure for domain
 */
async function createDirectoryStructure(domainPath) {
  const dirs = [
    'api',
    'components',
    'hooks', 
    'services',
    'repository',
    'types',
    'utils',
    '__tests__'
  ]
  
  for (const dir of dirs) {
    await fs.mkdir(path.join(domainPath, dir), { recursive: true })
  }
}

/**
 * Generate domain types
 */
async function generateDomainTypes(domainPath, entityName, domainName) {
  // Entity types
  const entityTypes = `/**
 * ${entityName} Entity Types
 * Generated by feature generator
 */

export interface BaseEntity {
  id: string
  created_at: string
  updated_at: string
}

export interface ${entityName}Entity extends BaseEntity {
  name: string
  description?: string
  status: ${entityName}Status
  organization_id: string
  created_by: string
  metadata?: Record<string, any>
  tags?: string[]
}

export type ${entityName}Status = 'draft' | 'active' | 'inactive' | 'archived'

export interface ${entityName}EntityWithRelations extends ${entityName}Entity {
  organization?: {
    id: string
    name: string
    slug: string
  }
  created_by_user?: {
    id: string
    full_name?: string
    email?: string
  }
}

export interface ${entityName}EntityPermissions {
  canView: boolean
  canEdit: boolean
  canDelete: boolean
  canShare: boolean
  canManage: boolean
}
`

  // DTO types
  const dtoTypes = `/**
 * ${entityName} Data Transfer Object Types
 * Generated by feature generator
 */

import { ${entityName}Entity, ${entityName}Status, ${entityName}EntityWithRelations } from './entity.types'

export interface Create${entityName}DTO {
  name: string
  description?: string
  status?: ${entityName}Status
  organization_id: string
  metadata?: Record<string, any>
  tags?: string[]
}

export interface Update${entityName}DTO {
  name?: string
  description?: string
  status?: ${entityName}Status
  metadata?: Record<string, any>
  tags?: string[]
}

export interface ${entityName}ListFilters {
  page?: number
  limit?: number
  search?: string
  status?: ${entityName}Status | ${entityName}Status[]
  organization_id?: string
  created_by?: string
  tags?: string[]
  created_after?: string
  created_before?: string
  updated_after?: string
  updated_before?: string
  sort_by?: 'name' | 'created_at' | 'updated_at' | 'status'
  sort_order?: 'asc' | 'desc'
}

export interface ${entityName}ListResponse {
  items: ${entityName}EntityWithRelations[]
  pagination: {
    page: number
    limit: number
    total: number
    total_pages: number
    has_next: boolean
    has_prev: boolean
  }
  filters?: ${entityName}ListFilters
}

export interface ${entityName}APIResponse<T = any> {
  success: boolean
  data?: T
  error?: {
    code: string
    message: string
    details?: any
  }
  meta?: any
  request_id?: string
}
`

  await fs.writeFile(path.join(domainPath, 'types', 'entity.types.ts'), entityTypes)
  await fs.writeFile(path.join(domainPath, 'types', 'dto.types.ts'), dtoTypes)
}

/**
 * Generate repository
 */
async function generateRepository(domainPath, entityName, tableName) {
  const repository = `/**
 * ${entityName} Repository
 * Generated by feature generator
 */

import { BaseRepository } from '@/lib/repositories/base.repository'
import { SupabaseClient } from '@supabase/supabase-js'
import { Database } from '@/types/database'
import { ${entityName}Entity, ${entityName}EntityWithRelations } from '../types/entity.types'
import { Create${entityName}DTO, Update${entityName}DTO, ${entityName}ListFilters, ${entityName}ListResponse } from '../types/dto.types'

export class ${entityName}Repository extends BaseRepository {
  protected tableName = '${tableName}'
  
  constructor(supabase: SupabaseClient<Database>) {
    super(supabase)
  }

  async findById(id: string, includeRelations = false): Promise<${entityName}EntityWithRelations | null> {
    try {
      let query = this.supabase
        .from(this.tableName)
        .select(this.buildSelectString(includeRelations))
        .eq('id', id)
        .single()

      const { data, error } = await query

      if (error) {
        if (error.code === 'PGRST116') return null
        this.handleError(error, 'findById')
      }

      return data as ${entityName}EntityWithRelations
    } catch (error) {
      this.handleError(error, 'findById')
    }
  }

  async findMany(filters: ${entityName}ListFilters = {}): Promise<${entityName}ListResponse> {
    try {
      const { page = 1, limit = 20, search, status, organization_id } = filters

      let query = this.supabase
        .from(this.tableName)
        .select(this.buildSelectString(true), { count: 'exact' })

      if (search) {
        query = query.or(\`name.ilike.%\${search}%,description.ilike.%\${search}%\`)
      }

      if (status) {
        query = Array.isArray(status) ? query.in('status', status) : query.eq('status', status)
      }

      if (organization_id) {
        query = query.eq('organization_id', organization_id)
      }

      const from = (page - 1) * limit
      query = query.order('updated_at', { ascending: false }).range(from, from + limit - 1)

      const { data, error, count } = await query

      if (error) {
        this.handleError(error, 'findMany')
      }

      return {
        items: data as ${entityName}EntityWithRelations[],
        pagination: {
          page,
          limit,
          total: count || 0,
          total_pages: Math.ceil((count || 0) / limit),
          has_next: page < Math.ceil((count || 0) / limit),
          has_prev: page > 1
        },
        filters
      }
    } catch (error) {
      this.handleError(error, 'findMany')
    }
  }

  async create(data: Create${entityName}DTO): Promise<${entityName}Entity> {
    try {
      const userId = await this.getCurrentUserId()
      
      const { data: entity, error } = await this.supabase
        .from(this.tableName)
        .insert({ ...data, created_by: userId })
        .select()
        .single()

      if (error) {
        this.handleError(error, 'create')
      }

      return entity as ${entityName}Entity
    } catch (error) {
      this.handleError(error, 'create')
    }
  }

  async update(id: string, data: Update${entityName}DTO): Promise<${entityName}Entity> {
    try {
      const { data: entity, error } = await this.supabase
        .from(this.tableName)
        .update({ ...data, updated_at: new Date().toISOString() })
        .eq('id', id)
        .select()
        .single()

      if (error) {
        this.handleError(error, 'update')
      }

      return entity as ${entityName}Entity
    } catch (error) {
      this.handleError(error, 'update')
    }
  }

  async delete(id: string): Promise<void> {
    try {
      const { error } = await this.supabase
        .from(this.tableName)
        .update({ status: 'archived', updated_at: new Date().toISOString() })
        .eq('id', id)

      if (error) {
        this.handleError(error, 'delete')
      }
    } catch (error) {
      this.handleError(error, 'delete')
    }
  }

  private buildSelectString(includeRelations: boolean): string {
    const base = '*'
    
    if (includeRelations) {
      return \`\${base},
        organization:organizations!${tableName}_organization_id_fkey(id, name, slug),
        created_by_user:users!${tableName}_created_by_fkey(id, full_name, email)\`
    }
    
    return base
  }
}
`

  await fs.writeFile(path.join(domainPath, 'repository', `${entityName.toLowerCase()}.repository.ts`), repository)
}

/**
 * Utility functions
 */
function toPascalCase(str) {
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase()
}

function toSnakeCase(str) {
  return str.replace(/([A-Z])/g, '_$1').toLowerCase().replace(/^_/, '')
}

function toPlural(str) {
  if (str.endsWith('y')) {
    return str.slice(0, -1) + 'ies'
  }
  if (str.endsWith('s') || str.endsWith('sh') || str.endsWith('ch') || str.endsWith('x') || str.endsWith('z')) {
    return str + 'es'
  }
  return str + 's'
}

async function pathExists(path) {
  try {
    await fs.access(path)
    return true
  } catch {
    return false
  }
}

// Additional generation functions would be implemented here...
// generateService, generateAPIHandlers, generateHooks, generateComponents, etc.

console.log('Feature generator CLI ready. Use --help for usage information.')